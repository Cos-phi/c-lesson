---
title: "第三回 バイナリやアセンブリから見るC言語とリンカ"
layout: page
---

<style>
   .column{
        padding: 0.5em 1em;
        margin: 2em 0;
        color: #5d627b;
        background: white;
        border-top: solid 5px #5d627b;
        box-shadow: 0 3px 5px rgba(0, 0, 0, 0.22);
    }
</style>

第三回では、第二回で学んだバイナリやアセンブリの知識を元に、C言語の理解を深めていきます。

オブジェクトファイルやリンクなどを理解し、実行時のローダーの基本を理解する事で、コンパイルやリンク、実行した時などのエラーを自分で解決出来るようになります。

また、C言語の実際の挙動を調べる為にコンパイラにアセンブリを生成させて、それを調べる、とう事を学びます。

第三回は[第二回 簡易アセンブラとディスアセンブラを作ろう](arm_asm.md)の続きです。
第二回を終えている事を前提に解説します。



# 01 アセンブリからC関数を呼ぶ

第二回では、ARM向けのコードはフルアセンブリで書いてきました。

ですがC言語のメリットの一つは、アセンブリとの親和性の高さです。
具体的にはアセンブリからC言語の関数を呼んだり、逆にCからアセンブリの関数（？）を呼んだりできます。

ここでは、最低限のセットアップだけでCの関数をアセンブリから呼ぶ、という事をやってみましょう。

### C言語の関数はアセンブリからどう見えなくてはいけないか？

C言語の関数がアセンブリからどう見えなくてはいけないのか？というのは、
実はC言語の仕様というレベルでは決まっていません。
決めるのは言語仕様では無く、ターゲットとなる環境が決めています。

各環境ごとのコンパイラが、C言語の仕様をターゲットの環境の定めるアセンブリのルールに変換する、という責任を持っている訳です。

ARMの場合は以下の文書が「C言語の関数は、アセンブリからどう見えないといけないか？」という決まりを説明したものになります。

[ARMのProceduer call standard](https://developer.arm.com/products/architecture/cpu-architecture/a-profile/docs/ihi0042/e/procedure-call-standard-for-the-arm-architecture)

要約すると

- r0, r1 r2...と引数に使え
- r13にはスタックに使うアドレスをセットしておけ
- スタックはstmdb-ldmaiの方向に伸ばせ

という風になってないといけない、という事が書いてあります。

ドキュメントを頑張って読むよりは実際に見てみる方が早いので、以下、実際にやっていきましょう。

### volatile使ってC言語側でprint_msgを作る

```
sources/06_c_function/call_c
```

にある。hello.cの先頭にあるコメントを読んで、同じコマンドを実行してみましょう。
いつもの通りHello Worldが表示されたと思います。

ここでvolatileというのは、C言語のコンパイラにUARTのアドレスなど特別な意味を持つ、という事を教える為のキーワードです。
これが無いとただ無意味にメモリに値をひたすら上書きしているだけ、とコンパイラは判断し、最適化で最後に書き込んだ値しか書き込んでくれません。

そこでvolatileというキーワードをつけて、ここへの代入はメモリとは違って意味があるので、最適化しないでください、とコンパイラに指示を出します。

### hello_c.sを眺めてみる

以下ではhello_c.sとhello.cが実際にどう実行されていくかを見ていきましょう。

アセンブリ側は以下のようになっています。

```
.globl _start
_start:
    ldr r13,=0x07FFFFFF
    bl hello_c
loop:
    b loop
```

まずldr命令でr13にスタックに使うメモリのアドレスを指定している。これは2.5でやった奴ですね。

そして次が新しい。bl hello_cという行。
blはr15を保存しつつジャンプする、という奴でした。
問題はhello_c。

これはラベルに見えるけれど、そのラベルはこのファイル内には無い。
どこにあるか？というと、hello.cの側にあります。

次にこちらを見ていきましょう。

### hello.cを見てみる

ではC言語側を見てみましょう。

すると、以下のような関数が定義されています。

```
int hello_c() {
    ...
}
```

これが先ほどblしていたhello_cというラベルの正体になります。

もう少し詳しく見るべく、このCのソースがどういうアセンブリになるかをコンパイラに吐かせてみましょう。
その為には-Sというオプションを付けます。

sources/06_c_function/call_cのhello.cをコンパイルしてアセンブリを吐く。

```
arm-none-eabi-gcc -O0 -fomit-frame-pointer hello.c -S -o hello_gcc.s
```

オプションの-oでは出力先のファイル名を指定します。これでhello_gcc.sというファイルが生成される。
中を見てみましょう。

最初の方に.eabi_attributeとかがずらずら出ますが、これらはあまり気にしないのがゆとり（自分も良く知りませんし、無くても最終的には同じバイナリになります）。

その次に、hello_cというラベルがある。

```
hello_c:
        @ Function supports interworking.
        @ args = 0, pretend = 0, frame = 0
        @ frame_needed = 0, uses_anonymous_args = 0
        @ link register save eliminated.
        ldr     r3, .L3
        mov     r2, #72
        strb    r2, [r3]
        ldr     r3, .L3
        ...
```

.L3ってなんだ？というと、最後の方に埋め込まれている、UARTのアドレスです。

```
.L3:
        .word   270471168
```

270471168ってなんだよ、というと、0x101f1000の事です。

r3にこのアドレスを入れて、あとはひたすらアスキーコードをstrbでこのアドレスに代入している訳ですね。
ここまで進めてきた人なら、この程度のアセンブリを読むのはなんでも無いでしょう。

最後の所はちょっと興味深い。


```
hello_c:
...
        mov     r3, #1
        mov     r0, r3
        bx      lr
```

lrはr14の事です。bxはthumb命令が絡むので詳細は説明しませんが、ようするにbの事です。

r3に一回代入しているのは意味が分かりませんが(コンパイラはたまにこういう意味の無いコードを生成する)、ようするにr0に1を入れて、b r14してます。

これがC言語の関数という物をコンパイラがコンパイルする時の基本になります。

1. r13はすでに適切にセットされていると思う
2. 関数名と同じラベルを作る
3. 関数の最後ではr0に結果を入れてb r14する（つまりr14には呼び出し元のアドレスが入っている）

基本的にはこういうコードを生成しています。hello.cのソースと、生成したアセンブリを良く見比べて、この事を確認してください。

 
### 課題: アセンブリから文字列を渡して表示してみる

アセンブリ側からC言語の関数に何かを渡してみましょう。
以下の場所

sources/arm_asm/06_c_function/call_c_msg

に、print_msg.cとmain.sというファイルが作ってありますが、main.sの方は未完成です。
これを完成させてください。(print_msg.cの先頭に実行すべきコマンドがコメントで書いてあります)

print_msg.cは以下のような中身になっています。

```
#define UART ((volatile char *)0x101f1000)

void print_msg(char *s) {
    while(*s) {
        *UART = *s++;
    }
}
```

アセンブリは、main.sというファイル名のファイルに書いて行く事にします。
先ほどのhello.sを参考に書いてください。

ヒント:

どうやって呼び出したらいいか想像する為には、print_msg.cのアセンブリを吐かせてみましょう。
例えば以下みたいなコマンドで、tmp_print_msg.sというファイルにアセンブリが吐かれます。

```
arm-none-eabi-gcc -O0 -fomit-frame-pointer print_msg.c -S -o tmp_print_msg.s
```

変数を渡すのに関係ありそうな所を抜き出すと以下のようになっています。

```
print_msg:
        sub     sp, sp, #8
        str     r0, [sp, #4]
        b       .L2
.L3:
...
.L2:
        ldr     r3, [sp, #4]
        ldrb    r3, [r3]        @ zero_extendqisi2
        cmp     r3, #0
        bne     .L3
        nop
        add     sp, sp, #8
        @ sp needed
        bx      lr
```

なかなか解読は大変ですが、r0を\[sp, #4\]に入れて、あとはこの\[sp, #4\]をC言語側の変数sのように使っているようです。

ですからr0に変数の先頭のアドレスが入っていれば良さそう？

## Cの関数の呼び方まとめ

1. r13にスタックとして使うアドレスをセット
2. r0とかに引数をセット
3. 関数名のラベルにbl

これでCの関数をアセンブリから呼べます。

逆にアセンブリの側で、上記のルールと同じに見えるラベルを用意してやれば、C言語の関数として呼ぶ事が出来ます。

# 02 分割コンパイルとリンク

分割コンパイルとリンカについて簡単に説明します。
C言語で開発をしていると、この辺のトラブルがちょくちょく出てくるので、基本的な事を知っておくと便利です。

ここでは以下のフォルダで作業します。

sources/arm_asm/06_c_function/sep_comp

### コンパイラとQEMUのセットアップ

ここからはC言語の方をメインにしたいので、bare metalで面倒な時は普通にOSがある場合でいろいろ試したい。

ここまではversatilePBを使ってきたのでこの上にLinuxを動かしてもいいのですが、少し大変なので手抜きとしてuser modeを使います。
これは厳密にはOSの上で動かすのとは違うのですが、実行ファイル側はOS上で実行するのと同じなので、ここでの説明としては十分です。

```
sudo apt install qemu-user
sudo apt install gcc-arm-linux-gnueabi
```

OS上で実行するバイナリを作る為には、コンパイルはarm-linux-gnueabi-gccという名前のコンパイラを使います。
objdumpなども同様です。少し名前が変わってるので並べておきましょう。

|bare metal| OSあり |
|----- | ----- |
|arm-none-eabi-gcc | arm-linux-gnueabi-gcc |

noneがlinuxに、eabiがenuabiになってる事に注意してください。

動作確認として、sources/arm_asm/06_c_function/sep_compで、以下を実行してみましょう。

```
arm-linux-gnueabi-gcc hello_printf.c main.c
qemu-arm -L /usr/arm-linux-gnueabi ./a.out
```

これでHello Worldと表示されればOKです。

ここからは基本的にはこのOSアリ版を使っていきますが、たまに先ほどやったcall_c_msgを見る事もあって、その場合はbare metal版になります。
コマンド名を間違えないように注意してください。

## 分割コンパイルをしてみる。

まずは分割コンパイルをしつつ、その途中に出来るオブジェクトファイルなどを簡単に覗いてみます。

### 分割コンパイルのやり方

gccやclangというコマンドは、コンパイラと呼ばれていますが、
実際はコンパイル以外の事もいろいろやってくれます。

具体的には以下の四つの作業を順番に行います。

1. プリプロセッサの展開
2. コンパイル
3. アセンブル
4. リンク

これらは一気に行われますが、一つだけやらせる事も実は出来る。

例えば-Eのオプションをつけると、プリプロセッサの展開だけやってくれます。
プリプロセッサとはマクロとかincludeとかifdefとかシャープで始まるそういう奴です。
昔はC言語以外のスクリプトとか設定ファイルでマクロを使って、Cのプリプロセッサで処理させるとか結構やられてたので良く使いましたが、近年ではマクロのデバッグ目的でしか使わなくなりました。

コンパイルだけを行うのは-Sです。これは後述します。

アセンブルまでで止めるのは-cです。
このオプションを付けると、コンパイラが生成したアセンブリをアセンブラがバイナリに変換してオブジェクトファイルにします。

例えば以下のようにするとmain.oが出来ますし、

```
arm-linux-gnueabi-gcc -c main.c
```

以下のようにすればhello_printf.oが出来ます。

```
arm-linux-gnueabi-gcc -c hello_printf.c
```

main.cにはprint_somethingの実装も無ければstdio.hをincludeもしていませんが、-cをつけるとオブジェクトファイルを生成する事が出来ている事に注目してください。

アセンブルまでならすべての「シンボルが解決」されている必要は無いのです。
「シンボルが解決」という事について、以下で少し見ていきます。


### nmでシンボルを確認する

シンボルを確認する方法は幾つかありますが、nmコマンドを使うのが一番普通のやり方だと思います。

例えば以下のように実行すると、main.oのシンボルが確認できます。

```
nm main.o
```

なお、この場合nmは現在実行しているマシンでの環境のnmが使われてしまいますが、nm自体は他の環境でも動くのでこれでも問題無いはずです。

厳密にはgccやobjdump同様、ターゲットの名前が前についた方を実行するのが正しい。

```
arm-linux-gnueabi-nm main.o
```

これを実行すると、以下のような表示が出るはずです。

```
00000000 T main
         U print_something
```

nmの出力には三つのセルがあり、それぞれ、

- 値
- シンボルの種類
- シンボルの名前

が表示されます。一行目は値が00000000、種類がT、名前がmainという意味です。
二行目は値がありません。

種類はTがテキストでUが未解決、という意味です。
種類の詳細はググれば解説が出てくると思いますが、例えば[nmのmanページ](https://nxmnpg.lemoda.net/ja/1/nm)などに書いてあります。ただ必要なのはそんなに多くないので出てくる都度簡単には説明します。

Tはテキストセグメントに配置されるシンボルという事ですが、この時点では定義されている、という意味くらいに思っておきましょう。

print_somethingはmain.cでは定義されてないので「この関数は使われてるけど、これが何なのかは僕は知らないよ～」という状態になります。これをシンボルが「未解決」と呼びます。

hello_printf.oの方も試してみると以下のような出力になると思います。

```
00000000 t $a
00000000 T func1
00000024 T print_something
         U puts
```

ドルaが何かは私も知りません。あまり気にしないでいきましょう。

func1とprint_somethingというのがTなのでこのオブジェクトファイルで定義されている事になります。

そしてここから呼び出しているputsはstdio.hの中にある関数なのでこのオブジェクトファイルでは定義されていない、という事になる。


### オブジェクトファイルとは何か？

オブジェクトファイルとは、大まかには二つの情報が入ったものです。

1. シンボル
2. バイナリ

バイナリはアセンブラや逆アセンブラを作った時に操作してきた、あのARMのバイナリです。
ですが、オブジェクトファイルの時点では、最終的なアドレスは決まってない。
このオブジェクトファイル内だけの相対アドレスとして、先頭が0番であるかのようにバイナリを生成します。

この辺の事はobjdumpをしてみると分かりますが、ちょっと解説を書くのが面倒なので割愛。自分でやってみてください（誰か解説書いてPRくれたら取り込みます）

この他に、シンボルという情報も入っています。
これは、このオブジェクトファイル内で定義されている関数の名前や、このオブジェクトファイルから参照されている関数の名前です。

この定義されている名前と必要な名前の情報を、リンクという過程で「解決」して一つのバイナリにくっつけます。


### 2つのアセンブリファイルをリンクしてみる

リンクは、本当はldというコマンドで実行します。
例えば以下のようなコマンドで、とりあえずリンクをする事が出来る。

```
arm-linux-gnueabi-ld hello_printf.o main.o -lc --entry main
```

ただこれでは実行する時にld.so.1がどうとか、で怒られます。
C言語というのは、暗黙のうちにcrt0.oや幾つかのライブラリなどをリンクする事を前提にした言語です。
リンクをする時にはそれらを指定してやる必要がある。

これが最近は結構多いので、このldコマンドを直接使ってオブジェクトファイルを実行する事はあまり無くなりました。

gccコマンドなどを使えば勝手にこの辺の事はやってくれるので、以下のようにリンクもgccコマンドを使ってしまうのが簡単で良いでしょう。

```
arm-linux-gnueabi-gcc hello_printf.o main.o
```

これが実際にはどれだけの事をやってくれるかは、-vオプションを付けるとみる事が出来ます。

さて、リンクしたら先ほど未定義だったものが解決されているのを確認。

```
nm a.out
```

いろいろなライブラリなどがリンクされるので、知らないシンボルが大量に出てくると思いますが、気にしないで知ってる所だけ見ましょう。

すると以下みたいになってると思います。

```
000103fc T func1
00010444 T main
00010420 T print_something
         U puts@@GLIBC_2.4
```

func1, main, print_somethingは解決されました。
putsはUのままですが、GLIBC_2.4というのが使われる事が分かります。

これは共有ライブラリとして実行時に解決されるのだと思いますが、その辺の事は今回は解説しません（C言語の入門からは少しはみ出てしまうので）。

なお、コンパイル時に-staticというオプションをつけると、この辺の物もリンクできます。
以下のコマンドで確認できます。

```
arm-linux-gnueabi-gcc hello_printf.c main.c -static
nm a.out
```

こうすると、前回よりもさらに大量にシンボルが出てくると思いますが、その中から頑張ってputsなどを探すとWになっている事が分かります。
この辺は自分もそんなには詳しくないので深入りはしません。

### 解決されてないシンボルのバイナリを眺める

次にmain.oをobjdumpしてみましょう。以下のコマンドになります。

```
arm-linux-gnueabi-objdump -S main.o
```

すると以下のような出力が得られるでしょう。

```
00000000 <main>:
   0:   e92d4800        push    {fp, lr}
   4:   e28db004        add     fp, sp, #4
   8:   e59f000c        ldr     r0, [pc, #12]   ; 1c <main+0x1c>
   c:   ebfffffe        bl      0 <print_something>
  10:   e3a03000        mov     r3, #0
  14:   e1a00003        mov     r0, r3
  18:   e8bd8800        pop     {fp, pc}
  1c:   00000000        .word   0x00000000
```

今となってはかなり見慣れた部分もあると思いますが、オブジェクトファイルだとちょっとこれまで見てきた物と違う所もあります。

1. アドレスが0から始まっている
2. 4行目のbl、ジャンプ先は自分自身になっている（ebfffffeが自身のアドレスになっているのはもう読者の皆様の方が詳しいでしょう）
3. 3行目のldr、ロードしている先は1cになっているが、その1cの行（最後の行）は.wordで0が埋め込まれている

さて、次にリンクしてa.outをobjdumpしてみましょう。
リンクは以下の方法とします。

```
arm-linux-gnueabi-gcc hello_printf.o main.o
```

ずらすら出てきてしまいますが、mainの所を見ると以下のようになっています。

```
00010444 <main>:
   10444:       e92d4800        push    {fp, lr}
   10448:       e28db004        add     fp, sp, #4
   1044c:       e59f000c        ldr     r0, [pc, #12]   ; 10460 <main+0x1c>
   10450:       ebfffff2        bl      10420 <print_something>
   10454:       e3a03000        mov     r3, #0
   10458:       e1a00003        mov     r0, r3
   1045c:       e8bd8800        pop     {fp, pc}
   10460:       000104d4        .word   0x000104d4
```

1. blのとび先は10420になっている(ebfffff2)
2. 最後の行の.wordには0x000104d4という謎のアドレスが入っている

一応次回予告的にこのアドレスの中身を見る方法も書いておきましょう。
それは-jと.rodataというオプションをつけます。

```
arm-linux-gnueabi-objdump -S -j .rodata a.out
```

すると以下のような出力になると思います。

```
Disassembly of section .rodata:

000104d0 <_IO_stdin_used>:
   104d0:       01 00 02 00 48 65 6c 6c 6f 20 57 6f 72 6c 64 00    ....Hello World.
```

### ふたたび、オブジェクトファイルとは何か？

オブジェクトファイル、というのは、ほとんど最終的なバイナリと同じ物が入っていますが、以下の点が異なります。

1. 先頭のアドレスは0という事にしてすべてのバイナリが構成されている
2. ファイルの外へのジャンプはいい加減なアドレスになっている（自身へのアドレス）
3. グローバル変数などのアドレスは0になっている

そして2や3は、あとで「解決」出来るようにシンボルのテーブルという付属のデータがある。
これがnmコマンドで表示される物です。

そしてリンク、という事をすると、このシンボルテーブルを使ってアドレスを「解決」します。
これは簡易アセンブラを作った時に、最後にラベルのアドレス解決をやったのと似た作業ですね。

それでは以上を元に、リンクについてもう少し細かい話をしていきます。

## リンク入門

ここまで見てきた分割コンパイルの話を元に、リンクという物について解説してみたいと思います。
リンクというのはC言語とプラットフォームの境界に当たる所なので、
以下の話はLinux特有の話とC言語全般の話の両方を含みます。

個人的にはC言語とUnixの境界を議論するのはあまり意味が無いと思っているので、このページでもあまり区別しません。

### C言語と三つのセクション

まず、C言語のコンパイル結果というのはアセンブリになるのですが、
このアセンブリは疑似命令などを使って、三つの「セクション」と言われる領域に分けてバイナリを生成します。

セクションには以下の三つがあります。

1. text
2. data
3. bss

textはプログラムのコードが置かれるリードオンリーな領域です。
dataとbssはグローバル変数が入る領域です。
dataとbssの違いは以下で見ていきますが、dataが初期化されるグローバル変数、bssが初期化されないグローバル変数を置く場所です。

bssとは何か、とか、なぜ初期化されないグローバル変数は扱いが違うのか、とかはあとで説明します。

以下具体例を見てみましょう。

### 宣言と定義

以下に、さまざまなグローバル変数や関数を置きました。

sources/arm_asm/06_c_function/link_test

まずはmany_symbols.cとmain.cのコードを見てみてください。
それほど難しいコードでは無いのですぐに理解出来ると思います。

C言語のグローバル変数と関数には、以下の二つがあります。

1. 宣言 (externがつく奴)
2. 定義

C言語はexternはあっても無くても同じような振る舞いをするので、あまり意識した事は無いかもしれません。
ですがリンクを考える時には基本を理解しておく必要があります。

原則としては、最終的にリンクされたバイナリにおいて、定義は一か所、宣言はいっぱいあって良い。
どこか一つのファイルに定義があって、他のファイルからは宣言を書いて参照する、というのが基本になります。

以上の記述は

- 関数
- 初期化のあるグローバル変数

では正しい。
ですが未初期化のグローバル変数は少し例外的な扱いをします。

C言語の未初期化グローバル変数は、複数同じシンボルの定義があったら、それは同じグローバル変数だと思います。
この時のグローバル変数の行が定義なのか宣言なのかは、区別は曖昧です。

C言語は初期化がある場合と無い場合でグローバル変数の扱いがすごく違う、変な言語です。

以上の具体例を、many_symbols.cの中身を見る事で確認してみましょう。

### Cのコードと三つのセクションの対応

many_symbols.cには、シンボルにかかわる限り、以下の要素があります。

|種類| ソースの中での名前|
|---- | ---- |
| 未初期化のグローバル変数定義| g_in_hello_uninit, g_text_uninit |
| 初期化のあるグローバル変数定義| g_in_hello, g_text, g_text_arr |
| staticなグローバル変数 | g_static_in_hello, g_static_in_hello2 |
| staticな未初期化グローバル変数 | g_static_uninit |
| グローバル変数の宣言 | g_in_main |
| 関数の定義 | print_something | 
| 関数の宣言 | func_in_main |

次に、many_symbols.cをコンパイルしてみてnmで見てみましょう。
以下みたいな感じです。

```
arm-linux-gnueabi-gcc -c many_symbols.c
nm many_symbols.o
```

すると、以下のような種類の出力になっているはずです。

|種類| nmでのシンボルの種類|
|---- | ---- |
| 未初期化のグローバル変数定義| C |
| 初期化のあるグローバル変数定義| D |
| staticなグローバル変数 | d |
| staticな未初期化グローバル変数 | b |
| グローバル変数の宣言 | U |
| 関数の定義 | T | 
| 関数の宣言 | U |

Tはテキストセクションの事です。dとDはデータセクションの事です。
bはbssセクションという奴です。

未初期化のグローバル変数は本来Bになるはずなのですが、C言語の特別扱いによりCという特殊な扱いになります。

これが特殊な扱いになっているのは、リンクをしてみると分かります。

main.cとリンクしてみて、a.outをnmで見てみましょう。

```
arm-linux-gnueabi-gcc many_symbols.c main.c
nm a.out
```

ちゃんと未初期化のグローバル変数はBになっていると思います。

まとめると、以下のようになっています。

- 初期化ありグローバル変数はデータセクション(d, D)
- 初期化無しグローバル変数はbssセクション(b, B)
   - ただしリンクされるまではC扱い
- 関数の定義はテキストセクション(t, T)
- 宣言だけだと未解決シンボル扱い(U)

### 参考リンク

nmのシンボルの種類は公式ドキュメントを見ると書いてあります。[https://sourceware.org/binutils/docs/binutils/nm.html](https://sourceware.org/binutils/docs/binutils/nm.html)

### おまけ

many_symbols.cを-Sオプションでアセンブリを吐かせてみると、g_textとg_text_arrの違いが分かるかもしれません。（あとでちゃんと解説します）



```
arm-linux-gnueabi-gcc many_symbols.c main.c
qemu-arm -L /usr/arm-linux-gnueabi ./a.out
```

# 03 elfとセグメントとローダー

elfフォーマットとダイナミックリンク無しの通常のLinuxのローダーやセグメントの話をする。

### elfとは？

elfとは、実行ファイルやオブジェクトファイルを格納するファイルフォーマットです。
ここまでの作業で生成された、例えば.oファイルはelfファイルだし、a.outもelfファイルです。また、bare metalの時に例えばhello_arm.elfというファイルを一時的に生成していました。あれもelfファイルです。

elfはどういう物か、というと、ざっくりとは「zipファイルみたいなもの」と言えると思う。

zipファイルというのはWindowsのエクスプローラでフォルダを右クリックして圧縮する時のあれの事です。

zipファイルには中に様々なファイルやフォルダが入っていて、中身というのはzipとは何かとは独立した概念ですよね。
例えばテキストファイルでもjpegファイルでもmp3ファイルでもzipの中に含める事が出来る。

elfもこれと同様で、いろいろなデータを含む事が出来るコンテナのファイルとなっています。
この中にARMの実行バイナリが入っていたりオブジェクトファイルのバイナリが入っていたりします。
elf自体は汎用のフォーマットなので別にARM以外のバイナリが入る事もあります。

また、バイナリの他にそれをどこのアドレスにロードしてもらうか、とかの付加情報も入っています。

### readelfコマンドを使って中を見てみる

elfのファイルを調べるにはreadelfというコマンドを使います。
なお、これはobjdumpと多くの点で役割がかぶっているコマンドで、objdumpでもreadelfでも出来る事は多い。
どっちのコマンドでやるべきなのか？とかはあまり気にせずにググって出てきた方を使っていればよろしい。

sources/arm_asm/06_c_function/sep_comp



### hello_arm.elfとhello_arm.binの違いを見る

hello_arm.elfをobjdumpしたりバイナリエディタで見たりして、ローダーやセグメントの話をする。

### elfの話

### text, data, bssセグメントの話

### 通常のLinuxのローダーの話

### hello_arm.oとhello_arm.elfの違い

リンカの話を補完する

### QEMU上のLinuxでelfを実行する



## コンパイラの吐くアセンブリをいろいろ見てみる

構造体の実体を渡すとどういうコードになるか、とか、配列のプラプラでちゃんとwritebackになるかとかを見る。（なるよね？）
sizeofも見たい。
文字列が配列とポインタでどう違うかも見たい。

sources/06_c_function/c_sources/hello_printf.c

あたりをやってみる。

gcc

```
arm-none-eabi-gcc -O0 -fomit-frame-pointer hello_printf.c -S -o hello_printf_gcc.s
```

frame-pointerの説明は今となっては不要と思うので-fomit-frame-pointerつけた。

clang

```
clang -emit-llvm hello_printf.c -c -o hello_printf.bc
llc -march=arm hello_printf.bc -o hello_printf_clang.s
```

llcの所でllvmが無いぞ、とか言われたらapt-get installしてください。

読む時のtips。

- sp, lr, pcはそれぞれr13, r14, r15の事。(http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.kui0097a/armcc_cihigdfh.htm)
- 疑似命令はasのドキュメントを読むのが良い（ただ要ら無さそうなのは適当に推測して調べないのも大切） (https://sourceware.org/binutils/docs-2.27/as/Pseudo-Ops.html#Pseudo-Ops)


clangの方が読みやすいので、以後はclangの方を見ていこうと思う（ちょっとコマンドラインめんどくさいけど）


### スタックウォークしてみる

clangあたりでスタックウォークする。

