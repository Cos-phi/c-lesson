---
title: "第一回 簡易PostScriptインタプリタを作ろう"
layout: page
---
<style>
   .column{
        padding: 0.5em 1em;
        margin: 2em 0;
        color: #5d627b;
        background: white;
        border-top: solid 5px #5d627b;
        box-shadow: 0 3px 5px rgba(0, 0, 0, 0.22);
    }
</style>

# 第一回 簡易PostScriptインタプリタを作ろう

やる事

- ハッシュ、線形リスト、スタックの実装
- 簡単なインタープリタの実装
   - 言語はPost Scriptのサブセット
   - 実行可能配列（関数リテラル相当）、ifelse、repeatくらいまで
- 3000行くらい。

Post Scriptのサブセットを実装してみたいと思います。

最初はForthを実装しようとしたのですが、制御構造の実装がやや面倒なので、
その辺がよりシンプルで美しいPost Scriptに変更します。（その歴史的な理由でフォルダ名などはforth_modokiになっています。すみません）。

Post Scriptは触るとすぐわかるけど説明するとややこしい言語仕様なので、作りながら言語仕様自体の説明はしていきます。
なお、Post Scriptは全く知らなくてもOKです。

### この回の狙い

- ステートマシンの書き方を学ぶ
- 簡単なパーサーの書き方を学ぶ
- 言語の処理系を実装する事でプログラム言語自体の理解を深める
- 基本的なコレクションを実装する
- ファイルの分割とインターフェースを考える事を学ぶ
- そこそこのコードを書く過程で良いコードの書き方を学ぶ
- ついでにスタックマシンも学ぶ


# 01 intのパーサーを作ろう

とりあえずintのパーサーを作る所から始めてみましょう。
初回なので進め方の説明もします。

## githubでの作業の進め方

1. githubのアカウントを作る
2. https://github.com/karino2/c-lesson/ をforkする
3. 自分のc-lessonをローカルにcloneする
4. ローカルで、karino-orignというブランチを作って、remoteにhttps://github.com/karino2/c-lesson.git を指定する
5. 問題は毎回ローカルでブランチを作り、ブランチをgithubにはプッシュする（マスターはいじらない）

こんな感じで作業をしていきましょう。

今回の問題は、01_int_parserというブランチでやるとします。

### int_parserの問題をやってみよう

sources/forth_modoki/01_int_parser/int_parser.c を修正しassertを通るようにしてcommitしてpushしてみて下さい。

# 02 intのパーサーを作ろう（getc編）

01では文字列をパースしました。

パーサーを作る時には、バッファにいったん読み込むか一文字ずつ取るか、という選択が最初にあります。
今回はファイルから一文字ずつ取る（つまりgetcやfgetc相当の物を使う）、という前提でパーサーを書きましょう。

今回はcl_getc()という関数をこちらで用意するのでそれを使ってください。

## パーサーとは何か

intのパーサーではそれほど考える必要もない事ですが、
今後だんだんと複雑にしてくので、ここでパーサーというものについて少し考えてみましょう。

パーサーというのは、文字を読んで行って、字句、というものに分割するものの事を言います。
字句というのはようするに「種類と値のペア」と思ってだいたい良い。
字句はトークンともいいます。

字句は数字とか記号とかを一単位とします。（以下具体例を見ていく方が分かりやすい）

### 一回の単位

使い勝手を考えると、一回parse_one()とか呼ぶと、一つ字句が返ってくるのが良い。

"1234 abc"とあったら、一回目のparse_one()では1234という数字を返し、次のparse_one()では' 'を返し、その次のparse_one()では"abc"を返すのが良い。

### 読んでしまった文字をどうするか

パーサーでは、例えば数字をパースするためには数字の一つ先の文字まで読む必要がある。
バッファに読み込んで作業するなら問題ないけれど、今回のようにcl_getc()で一文字ずつ読む場合、数字の次の文字を読んでしまった後に次のparse_one()にどう渡すか、という問題がある。

これはパーサーの性質による所だけど、標準的な文法では、いつも先読みは一文字までで大丈夫になっている。
興味のある人はLALR(1)の文法を調べると良いと思いますが、
今回はそんな難しい事は必要なくて、「一文字だけ先読みを許せばかなりいろんなものがパース出来る」という事だけ知識としてしっておけば良いと思います。

すると最後に読んだ文字、を返すようにし、次の呼び出しの時にそれを渡すようにしないといけない。
また、その文字が無ければ存在しない文字を渡す必要がある。これは'\0'で良いでしょう。


### 途中の場合は今回は考えない

また、パース対象が途中の物がありうるのか？というのもインターフェースを考える時に大切になります。
例えばユーザーが対話的に文字を入力する、というケースでは、
まだ終わってない状態でパースしたい事があるかもしれない。

そういう場合に最後のトークンは本来未確定なので、そこから再開できるようにインターフェースを考えないといけない。

ただ今回は、ハードコードした文字列でもファイルでも、いつも最後まで読み切れる、という前提でコードを書く事にします。

### 呼び出し元に返す必要があるもの

ここまでの話をまとめると、

1. 字句のタイプ
2. 字句の値
3. 読んでしまった次の文字

の三つを返す必要があります。


## 実際の作業手順

次に実際にどう進めるか、という話をしていきます。
最新のレポジトリではsources/02_int_parser_getc/が出来ているので、
この中のint_parser_getc.cを書き換えます。

### gitでfork元の更新を持ってくる

二回目なのでgitの解説を追加しておきましょう。
今回は02_int_parser_getcというブランチで作業する事にします。

まずこれを執筆中の2018/9/23日現在では、ここのサイトと同時に課題となるソースコードも更新している状態です。

そこで前問の状態から私がいろいろ更新しているので、新しく問題を解く時には、私の最新版を取ってきて、そこからブランチを作ります。

まず、karino-originに私の最新版を持ってきます。

```
git checkout karino-origin
git pull
```

次に、masterをkarino-originと同じ状態にします。

```
git checkout master
git merge karino-origin
```

一応github上のmasterを更新しておきます。

```
git push
```

次にこのmasterから今回用のブランチを作ります。

```
git checkout -b 02_int_parser_getc
```

このように、karino-originとmasterはいつも私のレポジトリの最新版と同じにして、
問題を解くときはその時点の最新版のmasterからブランチを作って下さい。

### 作業の進め方

まず字句のタイプを表すenumを作りましょう。NUMBERとSPACEでいいと思います。

次にparse_one関数を作りましょう。
字句の種類と値と先読みしてしまった文字を返す必要があります。

returnで先読みしてしまった文字を返し、字句の種類と値は引数で返しましょう。
返す用の引数はout_という名前にします。例えばint *out_val, int *out_typeなどです。

このparse_oneの型が決まったら一旦enumと合わせてslackで見せて下さい。

次にこのparse_oneを実装して、それを使うコードを書きます。

今回はPost Scriptを実装するので、連続するスペースは一つにしてしまって構いません。
parse_oneを'1  2'とスペースが二つある所に呼んでも、三回目は2を返してください。
二回目の値はスペース一つのフリをする、でOKです。


## Unit Testを書こう

とりあえずparse_oneの実装が出来て動いたら、Unit Testも書けるようにします。
（本来は順番が逆で先にUnit Testを実装するのですが、今回は教える内容の都合でこの順番にしています。）

Unit Testとは成功してるとOKとだけ表示するテストです。
失敗するとどこで失敗したかを表示します。
そして関数一つとか二つとか、なるべく小さい単位のテストを書きます。

細かい書き方はおいおい説明していくとして、まずはUnit Testを書けるようにcl_getc()を拡張しましょう。

### cl_getc()に外部から入力を指定できるようにする

現状はハードコードされたinputを元に順番に文字を返すcl_getc()ですが、
Unit Testの事を考えると外から文字を設定出来る方が望ましいです。

そこで、外部から文字を設定するAPIを足しましょう。

```
void cl_getc_set_src(char* str);
```

とします。これをヘッダファイルに足してcl_get.cの中に実装を書いてください。（posを0にリセットするのを忘れずに！）

これが終わったらいったん見せて下さい。

### 基本的なUnit Testを足そう

それでは次にUnit Testを足します。
テストは最初は"123"という内容に対してparse_oneがどうふるまうべきか、というテストを書いて、mainから呼ぶ事にします。

テストの関数の名前は

```
void test_parse_one_123()
```

としましょう。

mainはこんな感じにします。

```
int main() {
    int answer1 = 0;
    int answer2 = 0;

    // ここから違う

    test_parse_one_123();

    // 入力を元に戻す
    cl_getc_set_src("123 456");

    // 以下は元どおり
    // ...

    // verity result.
    assert(answer1 == 123);
    assert(answer2 == 456);

    return 1;
```

ここまで終わったら一回見せて下さい。

### 空白のあるケースのUnit Testを足そう

次にtest_parse_one_123_456を追加しましょう。"123 456"に対してどう動くか、というテストです。

ちゃんと間の空白もテストしてください。

以後はこのUnit Testで問題を出す事にします。
それを見ながら、Unit Testとはどういう物かをなんとなく学んでいって下さい。

# 03 intとシンボルと特殊文字のパーサーを作ろう

それではここまで書いてきたパーサーを、int以外にも拡張しましょう。
とりあえず、

- 「{」
- 「}」
- 「executable name」
- 「literal name」

の4種類の要素を追加する事にします。

まず最初の二つ、「{」はOPEN_CURLY、「}」はCLOSE_CURLYというenumとしましょう（curly braceで中かっこの意味）。

ここで見かけない言葉が二つありますね。executable nameとliteral nameです。

### Post Scriptの二つのname

nameとはPost Scriptにおける変数名の事です。
abcなどですね。

Post Scriptには二つのnameがあります。
executable nameとliteral nameです。

この二つが何なのかはあとで説明します。
現時点ではパースする対象としてそういう二つがあると思ってください。
パースに必要な事だけここでは説明します。

最初に例を挙げると

**executable name**

- abc
- hello
- x
- abc123

などがexecutable nameです。変数に使われます。

**literal name**

- /abc
- /hello
- /x
- /abc123

などがliteral nameです。スラッシュで始まって、あとはexecutable nameと同じです。

厳密な言い方をするとexecutable nameは、「ローマ字で始まってスペース以外が続く文字で構成された文字列」です。

「literal name」はスラッシュで始まり、そのあとローマ字から始まる文字列です。
ここはPost Scriptはもっと変なものもnameに使えますが、サブセットという事であまり細かい仕様は決めない事にします。


簡単のため、nameは254文字以下としましょう。
255文字以上のnameは来ないものと仮定して、エラー処理などはしなくてOKです。
最初のスラッシュと最後のヌル文字も入れた256をNAME_SIZEとしてdefineしておくので、必要に応じて使ってください。

executable nameは、EXECUTABLE_NAMEというタイプで文字列をmallocして返す事にしましょう。

literal nameはLITERAL_DEFというタイプで文字列をmallocして返す事にします。
この時、先頭のスラッシュは取り除いてください。

## トークンの型を定義しよう

これまではout_valとout_typeという二つの変数で表していましたが、これを構造体にまとめる事にします。

以下のようにしたいのですが、

```
struct Token {
    enum LexicalType ltype;
    int value;
};
```

ただ今回、valueはintじゃないものも入ります。
具体的には

- int
- 一文字のchar（'{', '}', ' 'のどれか)
- mallocしたchar*へのポインタ

の三つのどれかになります。

charをintに入れるのは仕様上OKなのですが、ポインタは64bit CPUの場合入らない場合があります（C言語の仕様としては入らなくても入ってもOKなので実装依存）。

そこで、これらを全部入れる、unionを定義したいと思います。

### unionを使って複数のトークンのどれかを表す構造体を作る

さて、union。
Cの入門書には必ず書いてあるけど、読んでも構造体との違いが良くわからないものの代表ですね。

ここでまた良く分からないunionの説明を繰り返してもいいのですが、どうせ読んでもなんだか良く分からないと思う。
という事でここでは、実際に使ってみながら勝手に学んでもらう、という方針を取る事にします。

今回は以下のように定義します。

```
struct Token {
    enum LexicalType ltype;
    union {
        int number;
        char onechar;
        char *name;
    } u;
};
```

これをどう使うのか、は、03_parser/parser.cの中のparser_print_all()を読んでみて下さい。

## parse_one()を実装しよう

ここからは、parse_one()とそのUnit Testを実装してもらいます。

今回は私が構造体の定義やparse_one()のシグニチャなどを準備しておきました。
そこでまずは私の書いた内容を理解する事から始めてみてください。

### parser_print_all()を読む

まず大きな関数として、parser_print_all()というのがあります。
これはparse_one()を呼び出してトークンをprintする、という事をしています。

この中で、tokenとそのtoken.uがどう使われているかを見る事で、unionの使い方を理解してみてください。

**freeしないの？**  
parser_print_all()は、token.u.nameをfreeしてません。これはメモリリークになります。
長く動き続けるプログラムであればfreeはすべきです。
そうで無い場合にどうするか？というのは意見が割れる所で、C言語においてfreeをすべきかどうかは定期的に論争が発生します。  
　  
このシリーズでは「mainに近い方のレイヤで全て実行して終了するだけ」という場合はfreeしない事にします。また、説明上それほど重要でないと思う時もfreeしない事にします。
この辺は結構適当に決めるので、気になるなら自分でfreeしてくれてもOKです。  
　  
長く動き続ける組み込みのプログラムなどではリークは大問題なのでちゃんと全部解放出来ているのかをすごく時間をかけてチェックしますし、
この忘れは製品の回収騒ぎにまで発展し、結構な被害総額を生む事もあります。
だから組み込みで使われるC言語において、free忘れは重大違反だ…というとそうとも言い切れなく、組み込みで長く動く類のCプログラムはそもそもmalloc自体しない（そういうものが無いなど）という場合も結構あります。  
　  
Unixなどのサーバーで長くデーモンとして動くような物でもメモリリークは大問題となります。ですが、そういう用途でC言語を使う事は随分減りました。
C++であればそもそも手でdeleteを呼ぶのでは無く、スマートポインタなどを使ってスタックに置く方が正しいので、やはりfreeに相当するものを頑張ってチェックする、という機会はあまりありません。  
　  
カーネルの中やドライバなどでは相変わらずfreeし忘れは大問題です。この用途でC言語が使われる事は多く、またmallocに相当するものが必要になるものも結構ありますね。
この辺をやる人の場合は議論の余地なくfreeし忘れは大問題です。  
　  
C言語でどれくらいmallocしたものをfreeしなくてはいけないシチュエーションが多いか、は時代に依る話で、昨今は随分減ったというのが自分の認識です。
リソースの管理として終了が必要なものはあるのだから最初からしっかりクセをつけるべきだ、というのも一理あると思いますが、そこから先は宗教戦争になるので読者の皆様が好きにしたら良いでしょう。
{: .column}

### 二つのUnit Testを読む

次にUnit Testが二つだけ用意されています。
この二つを読んでみてください。
test_parse_one_number()は前回書いてもらった物とほとんど変わらないので、読めばわかると思います。

test_parse_one_empty_should_return_END_OF_FILE()は前回あまり明確に決まりを作らなかった、
空っぽのファイルを読ませたらどうふるまうべきか？という事についてのテストです。
今回は最後まで読んだ後にparse_one()を読んだら、END_OF_FILEというタイプを返すべき、という事に決めようと思います。


### まずはUnit Testを通すだけのparse_oneを実装する

既に書かれているコードの内容を理解したら、まずmainのparser_print_all()をコメントアウトし、
Unit Testを通す事から始めます。
前回とほとんと同じ内容となるので、前回のコードからコピペしてきて書いて下さい。

ここまで終わったら一度私に見せてください。

### executable nameのテストを足して実装しよう

executable nameは、ローマ字で始まって空白以外が続く文字としましょう。
テストとしては、以下で始めてください。

```
char* input = "add";
char* expect_name = "add";
int expect_type = EXECUTABLE_NAME
```

テストが追加出来たらparse_oneを実装する前に一回このテストがfailする事を確認します。

そのあとにparse_oneを実装してください。

### literal nameのテストを足して実装しよう

executable nameとほとんど同じですが、literal nameはスラッシュ、つまり'/'から始まる、という所が違います。

テストとしては、

```
char* input = "/add";
char* expect_name = "add";
int expect_type = LITERAL_NAME
```

としましょう。expect_nameにスラッシュが無い事に注意してください。

このテストもfailするのを確認してからparse_oneを実装してください。

### 中括弧も実装しよう

以下同様にOPEN_CURLYとCLOSE_CURLYも実装してください。
全部が終わったら、最後にparser_print_allを実行してみて動く事を確認してください。

動かなかったら必ずその理由を明らかにするUnit Testを追加してから直しましょう。


# 04 スタックを作ろう

数字とリテラルネームを出し入れ出来るスタックを作りましょう。

stack.cとstack.hというファイルに実装し、stack_push, stack_popという関数と、
stack_print_allを作って下さい。

スタックサイズは

```
#define STACK_SIZE 1024
```

くらいでお願いします。

### まずインターフェースを決める

まず04_stackというディレクトリを作って、その中で作業してください。
今回はファイルから全部自分で作って下さい。ブランチもこれまで同様作ってください。

スタックには数字とリテラルネームの二つをpushしたりpopしたり出来る必要があります。

とりあえずstack_push()、stack_pop()の型が決まったらいったん見せて下さい。

### 次にUnit Testを書く

何もないときにpop呼んだ時、一つpushしたとき、一つpushしてpopした時、二つpushしてpop二回した時の内容をそれぞれチェックする位のテストを書いて見せて下さい。
なお、テストを書くのにstack_push()とstack_pop()以外が必要になったら適宜追加してください。

そのあとはそれを実装します。

なるべく、一度でテスト一つずつ通すように実装を進めます。

まず何もない時にpop呼んだ時のテストを通るだけのコードを書き、
次に一つだけpushがちゃんと動くように張りぼてっぽいものを書き、次に二つのpushが動くちゃんとした実装に直す、という具合です。


# 05 addだけのevalループを作ろう

ここまでパーサーとスタックを作ったので、PostScriptのコアとなるevalを書く事が出来るようになりました。
これを実装していきましょう。

## PostScript入門

まずevalを作るにあたり、今更ですが、そろそろPostScript自体の話をしていきましょう。
なお、GhostScriptという物が入っている環境がある場合、gsというコマンドで対話的インタプリタが立ち上がっていろいろ試す事が出来ます。

### 数字だったらpush

まずPostScriptにはスタックというものがグローバルに一つあります。
で、プログラムは空白区切りでテキストを区切って読んで行って、
数字だったらこのスタックにpushします。

だから、

```
1 2 3
```

と書いてあったら、スタックに1をpushし、次に2をpushし、次に3をpushします。

### 文字の単語なら関数と思って実行

addとかsubとかにぶつかると、関数呼び出しと思って実行します。

addというのは、スタックから二つ数字を取り出して足し算して結果をスタックに積みます。
だから、

```
1 2 add
```

と書いてあるとインタープリタは先頭から読んでいって、

1. まず最初に「1」を読んでスタックにプッシュします。
2. 次に「2」を読んでスタックにプッシュします。
3. 次に「add」を読んだら、これは数字じゃないので関数だと思ってaddを実行します。

addを実行すると何が起こるかはaddという関数の仕様という事になります。
PostScriptでは関数と呼ばず実行可能ネームと呼びますが、ここでは関数と言ってしまいます。なお余談ですが、親戚にあたるForthでは実行可能ワードと呼びます。

addは

- スタックから2つ値を取り出して
- それを足して
- 結果をプッシュする

という振る舞いをします。スタックにはこの場合1と2が入っているので、これを取り出すと、
スタックは空になります。
次に1+2を計算して、結果をスタックにプッシュするので、最終的には3が入ります。
疑似コードで書くと以下みたいな振る舞いです。

```
var a = pop();
var b = pop();
push(a+b);
```

以上を踏まえると以下のコードは何が起こるでしょうか？

```
1 2 3 add
```

答えだけ言うと、スタックには1と5が残ります。1が残る理由は分かるでしょうか？

```
1 2 add 3 add 4 add 5 add
```

と、

```
1 2 3 4 5 add add add add
```

は同じ結果になります（たぶん）。

3+2*(2+1)+4なら、

```
3 2 2 1 add mul add 4 add
```

とか書けます。数式からPostScriptに直すのは慣れればすぐ出来ますが、
PostScriptのコードから数式に戻すのはちょっと脳への負荷がありますね。

以後、必要になる都度他の要素は解説していきます。


### 外部サイト

必要な事は適宜解説していくつもりですが、ちゃんと一気に学びたい、というなら、
以下のサイトなどで学ぶと良いと思います。
PostScriptはすごくシンプルな言語仕様なので、他のプログラム言語の経験があれば主要な機能は10分くらいで学ぶ事が出来ると思います。凄い。

ただ言語の性質上、プログラム言語以外の解説が多いので手頃な解説が少ないという難点があります。

- [PostScript 基礎文法最速マスター](http://d.hatena.ne.jp/dayflower/20100203/1265185183)  
言語自体の解説として割と良いが、実行可能配列の解説が後ろの方なのがこのシリーズ的には惜しい。
- [PostScript Language Program Design (pdf)](https://www-cdf.fnal.gov/offline/PostScript/GREENBK.PDF)  
いわゆるGreen Book。英語が読めるならこの2.3から2章の終わりまでを読むのも良い。

## 今回実装する事

以上を踏まえて、とりあえずaddが動くようにしましょう。subやmulも実装してもいいんですが、
後で書き直す事になるのでやめておきます。

```
3 4 add
```

や、

```
3 7 add 5 add
```

などが動くようにevalループを書きましょう。

最後にスタックの中身が空じゃなかったら、その中身を出力するようにしておきます。

### まず前の課題から、パーサーとスタックを持って来よう

05_evalのディレクトリの中を実装していきますが、パーサーとスタックは自分が作ったものを持ってきて下さい。
別のブランチで作った物をどう持ってくるのか？という問題があるかもしれませんが、いったん別のディレクトリにcpするとかの原始的な方法でOKです。
（わからなかったらslackで聞いて下さい）

main関数は#if 0でコメントアウトしておいて下さい。

スタックのインターフェースをどうしたかが人に依るので、eval.cのUnit Testでスタックの中をチェックするコードは書いてません。
そこも書いてまずはリンクを通してテストがfailするのを確認します。

### 数字をスタックにプッシュするだけのテストを通そう

evalはparse_one()を呼んで、その中に応じて処理をswitchする感じになります。
03_parserで最初にparser.cに書いてあった、parser_print_all()を参考にしてみてください。
数字だったらpushする、は比較的簡単だと思います。

### 次にaddの処理をハードコードしよう

数字は比較的簡単と思います。
次はEXECUTABLE_NAMEですが、まずは

```
int streq(char *s1, char *s2);
```

という関数をstrcmpあたりを使って作ってください。イコールなら1、違ってたら0を返す感じです。

次に、nameが"add"だったら、スタックから二つ値をpopして足した結果をpushする、というコードを普通に書いてしまいましょう。
これでUnit Testは通るはずです。

将来的には関数ポインタなどを使う事になりますが、現時点ではここまでで次に進みましょう。


### 最小限のインタープリタが完成！

ここまで来ると、インタープリタとして最小限の機能が通る事になります。
cl_getc()をファイルから読み込むように直すのは簡単でしょう。(あとでやるのでまだやらなくてもOKです)

まだ足し算しか出来ませんが、それでもパースしてevalする、
インタープリタのコアとなる骨組みは出来た事になります。

ここまででも、結構複雑なプログラムを動かす事が出来ます。
例えば

```
1 2 3 add add 4 5 6 7 8 9 add add add add add
```

とかやると、たぶん動くでしょう。ゆとりなので答えが幾つになるか知りませんが、なんか出ると思います（55だっけ？）。
やろうと思えばmulやsubやdivも実装は出来るでしょう（ですがこの辺は後でハッシュ実装したあとの方が都合が良いのでここではまだ実装しなくてOKです）。

インタープリタは実装した物がそのまま動く普通のプログラムと違って、
食わせたコードが動くので、ちょっとなんかソフトウェアを作った、って感じがするのでは無いでしょうか。

とは言ってもこれではifもループも関数定義も無いので、まだまだインタープリタと他人に自慢出来る程ではありませんね。
という事で関数を作っていくべく、次はdefの実装に移りましょう。


# 06 ハッシュでliteral nameにdef出来るようにしよう

```
/onetwothree 123 def
```

としたら、以後

```
onetwothree
```

とすると123と書いたのと同じになるようにしましょう。
ここからは前回の05_evalにそのまま続きを書いて行きましょう。

前回の最後の状態から、新たに06_literal_nameというブランチを作り、そこで作業していってください。


### literal nameをスタックにプッシュしよう

まず、リテラルネームはスタックにプッシュするようにevalを書き換えましょう。
ここからはnameをリークさせるかちゃんと解放するかで結構コードが変わって来ますが、
今後は一度mallocした文字列は解放しない、という前提で書いて行きます。
勉強目的ですしね。

さて、解放を考えないなら、literal nameをpushするのはintとほとんど変わらないと思います。
intの変わりにポインタを入れて、さらにタイプとしてliteral nameを表すenumを入れればいいだけでしょう。


**解放したいならリファレンスカウントがオススメ**  
勉強目的ではリークする方がオススメですし、実際に使う時もリークで構わない事がほとんどだと思います。例えば真面目にVMを作る時も、そもそもコンスタントな文字列の扱いはmallocで別々に取ったりせずにコンスタントプール的なものをちゃんと作る事になりますし、
一見するほどこのコードでちゃんとfreeしなくてはいけない事はありません。  
　  
ですが、もし真面目にfreeしてみよう、と思ったら、いちいち必要に応じてmallocしたりfreeしたりを繰り返すよりも、リファレンスカウントを実装するのが簡単でオススメです。
循環参照でリークするのは皆の知る通りですが、PostScriptでそれが発生するのは稀なので、昔のJavaScriptのリークほどひどい事にはなりません。  
　  
リファレンスカウントを実装するなら構造体に文字列ポインタの他にref_countみたいな変数を持たせて、mallocした時に1にし、以後スタックにコピーする時などには+1し、スタックからポップする時やparse_oneで得た構造体が要らなくなった時などには-1します。0になったらフリーします。
実装は簡単な割には動いているのを確認してリークなくしたりしていくのはまぁまぁ楽しいので、趣味として一回くらいやってみても良いと思います。
ただし、そこまでやるならC言語以外の選択肢を検討するタイミングかな、と個人的には思います。 C++ならshared_ptrとかありますしね。
{: .column}

## defを実装する

今回は数値だけのdefを実装します。
defはちょっと難しいので少し丁寧に説明します。

### そもそもdefとはどんなものか？

defはスタックのtopから二番目に入ってるリテラルネームに、topの値をbindします。

コードの例を見てみましょう。

```
/hoge 123 def
```

これは、他の言語でいう、例えば

```
var hoge = 123;
```

とかと同じような意味です。
以後は、

```
hoge 2 add
```

とかいう風に、まるで123という数字のように使えます。

defは必ずスタックの二番目にリテラルネームが入っている、という前提で機能します。
入ってない時はprintfでそのむね出力して、あとは好きにして下さい。（無視して動いてもexitで終わってもOK)。

### まずは辞書のAPIを考える

defを実装する為には、変数で値をルックアップ出来る何かが必要になります。
他の言語では辞書を使う所ですね。
そこでここでは、まず辞書のAPIを考えて、一番単純だが遅い実装から始めます。

辞書としては、スタックと同じ要素が入れられればいいでしょう。
スタックの時の構造体を使ってもらっていいのですが、ここではそれが

```
struct Element {
    ...
}
```

という名前の構造体で定義されているとしましょう。

すると辞書のAPIとしては、

```
void dict_put(char* key, struct Element *elem);
int dict_get(char* key, struct Element *out_elem);
void dict_print_all();
```

の三つくらいがあれば良いでしょう。dict_getは、キーが無ければ0を、キーがあれば1を返すとします。

### 最初の実装：配列に入れて、ひたすらstreq

最初は、一番頭を使わない実装でいきましょう。
以下のようなデータに

```
static int dict_pos = 0;
struct KeyValue {
    char *key;
    struct Element value;
}
static sturct KeyValue dict_array[1024];
```

という構造体を用意して、dict_putは以下のような感じで実装します。

```
void dict_put(char* key, struct Element *elem) {
    if(すでにキーがdict_arrayに入ってたら) {
        dict_arrayのその場所をelemで上書き;
    } else {
        dict_array[dict_pos] = KeyValue(key, elem);
        dict_pos++;
    }
}
```

もちろんこれは疑似コードなので、これをC言語に翻訳してください。
1024よりもputされた時のコードは書かなくていいです（どうせすぐ書き直すコードなので）。

dict_get()は、

```
int dict_get(char *key, struct Element *out_elem) {
    for(int i = 0; i < dict_pos; i++) {
        if(streq(key, dict_array[i].key)) {
            out_elemに結果を詰める。
            return 1;
        }
    }
    return 0;
}
```

という感じにします。
ただ、dict_putの所でこのiに相当するものが必要になると思うので、その辺はちゃんと書き直してください。

### ハッシュテーブルを実装しよう

さて、



# 07 実行可能配列を実装しよう（ここが大変）

```
/onetwo {1 2} def
```

としたら、以後onetwoと書くと 1 2と書いたのと同じになるようにしましょう。

```
/plusone { 1 add } def
```

などと書くと、以後 plusone と書いたら 1 add と書いたのと同じになるようにします。


# 08 条件分岐とスタック操作とループを足そう

```
1 {1 add} {2 add} ifelse
```

としたら 1 addが、

```
0 {1 add} {2 add} ifelse
```

としたら 2 addが実行されるようにします。

```
4 {1 2} repeat
```

としたら、1 2 1 2 1 2 1 2したのと同じになるようなrepeatも実装します。

また、pop, dup, exch（上から一番目と二番目を交換）を実装します。
