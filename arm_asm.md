---
title: "第二回 簡易アセンブラとディスアセンブラを作ろう"
layout: page
---

<style>
   .column{
        padding: 0.5em 1em;
        margin: 2em 0;
        color: #5d627b;
        background: white;
        border-top: solid 5px #5d627b;
        box-shadow: 0 3px 5px rgba(0, 0, 0, 0.22);
    }
</style>


第二回はQEMUを使ってARMのバイナリを動かしたり、バイナリを生成したりディスアセンブルしたりするコードを書きます。

OSの無い環境でプログラムを動かす事で、C言語の土台の理解を深める事を目的とします。

- QEMUのベアボーン環境を使えるようになる
- readelf, objcopy, objdumpなどのコマンドに慣れ親しむ
- 簡単なARMのアセンブリを理解する
- 簡単なアセンブラとディスアセンブラを作る

# 何故アセンブラと逆アセンブラを作るのか？

C言語を勉強しよう、という時に、なんだか関係ない別の言語に見えるアセンブラ言語を学ぼうというのは「なんでよ！？」と思うかもしれません。

そこでここではまず、今回QEMUを使ってバイナリを動かしたり簡易アセンブラや逆アセンブラを作るモチベーションを説明したいと思います。

### C言語を理解するにはアセンブリを知っている方がいい

C言語はアセンブリ言語を知らなくても理解出来ます。
ですが、C言語はアセンブリ言語との親和性が高く、アセンブリ言語の理解があるとずっと出来る事も増えます。

また、初めて低レベルな事をやる時にはobjdumpやobjcopyなど多くのコマンドが一気に出てきて、
実際は大した事無い事でもなんだかすごく圧倒されてしまいがちです。
一度どこかで簡単な題材に対してobjdumpなどを使った経験を持っておくと、
そうした時にもひるまずに済みます。

### バイナリの処理の勉強になる

C言語に一番向いた処理、というのはバイナリを扱う処理だと思います。
逆アセンブラやアセンブラなどはバイナリ処理の代表的な構造を持っているので、
バイナリ処理の練習に適しています。

バイナリ処理はだいたい似たような構造となるので、どれか一つでやった事があるかどうかの差は大きい。
そういう訳でバイナリ処理の題材として手頃なのでやってみよう、というのがあります。

### 低レベルなプログラムは楽しい！

C言語の楽しさといえば低レベルプログラミングでしょう。
低レベルプログラムは、C言語の楽しさの割と中心的な所だと思います。（著者の個人的見解です）

特に規模の小さい低レベルプログラムが楽しい。
規模の小さい低レベルプログラミングは隅から隅まで理解出来ます。
これはプログラムにおいて低レベルプログラムだけでしか味わえない楽しさです。

一方で最近は低レベルでも皆大きなものを作りたがりがちで、
本などを買って来て読んでも、あまりこの楽しさは味わえません。
やはり簡単な例でバイナリを隅から隅まで理解する、というのは、
C言語を学ぶなら一回くらいやっておいてもいいでしょう。

### 何故ARMなのか？

最初x86でこの回を作る気だったのですが、x86のアセンブリ言語は歴史的事情からいろいろ複雑な仕組みになっている為、説明がややこしくなります。

一方ARMはいろいろな事が単純になっている為、低レベルの事を勉強するには手頃なターゲットとなっています。
また、C言語を書く必要があるシチュエーションではARMをターゲットにする方が今ではむしろ多いと思うので、実用性という観点からもARMを覚えておくのは悪くない、と思いARMをターゲットとしました。



# 01 QEMUの環境を作ろう

以下Windows 10のWSLを前提にします。昨今ではたいていの環境で似たり寄ったりのパッケージシステムがあるでしょう。

初回は環境設定を主な目的としています。これらが何を意味しているかについては、おいおい説明していきます。

### QEMUとARM用gccをインストール

今回はARM用のQEMU環境であるqemu-system-armと、ARM用のクロスコンパイルのためのパッケージであるgcc-arm-embeddedをインストールします。

```
sudo add-apt-repository ppa:team-gcc-arm-embedded/ppa
sudo apt update
sudo apt install gcc-arm-embedded

sudo apt install qemu-system-arm
```

### バイナリエディタをインストール

今回はバイナリの中身を調査する為、何らかのバイナリエディタを入れる事がオススメです。
大したサイズじゃないのでodコマンドなどで頑張ってもいいんですが、
今回はバイナリエディタをインストールする事にします。

なんでもいいんですが、私は最近はBz Editorに落ち着きました。

https://github.com/devil-tamachan/binaryeditorbz

試しに以下で出来るhello_arm.binをバイナリエディタで開いてみて下さい。

### hello_arm.sを動かしてみよう

sources/arm_asm/01_qemu_setup/hello_arm.s

に、UARTにhelloと表示するアセンブリが書いてあります。これを動かしてみましょう。

```
$ arm-none-eabi-as hello_arm.s -o hello_arm.o
$ arm-none-eabi-ld hello_arm.o -Ttext 0x00010000 -o hello_arm.elf
$ arm-none-eabi-objcopy hello_arm.elf -O binary hello_arm.bin
$ qemu-system-arm -M versatilepb -m 128M -nographic -kernel hello_arm.bin -serial mon:stdio
```

終了はC-a xです。

# 02 ARM アセンブリ入門

さて、前回はhello_arm.sというアセンブリ言語で書かれたプログラムを動かしました。
今回はこのアセンブリ言語について、簡単な入門をしていきたいと思います。

ARMのアセンブリの入門なんてweb上にいくらでもありそうだと思うのですが、どうもググっても手頃なのが見つからないので、自分で書く事にしました。

**アセンブラ？アセンブリ？**  
まず正しい定義としては、アセンブリ言語が正しい呼称でしょう。
そしてアセンブリ言語をバイナリにする為のツールがアセンブラとなります。
コンパイルする言語がコンパイラなのと同様です。  
　  
ただ最近の若い人は普通にアセンブラ、と言いますよねぇ。アセンブリ、とわざわざいうのはどっちかと言えば頭の硬いおっさん、って感じがして、どうなのか、という気もします。
この手の語源警察とかろくでも無い、と普段から思っているので。  
　  
ただ他人がアセンブラと言っているのは別に良いのですが、どうしても自分が言語の名前をアセンブラと呼ぶのには抵抗があるので、このシリーズではアセンブリと呼ぶ事にします。おっさん乙…
{: .column}

## アセンブリについての話題など

まずは言語自体の話に入る前に、周辺の雑談などからしてみたいと思います。
というのはアセンブリ言語というのはちょっとそれ以外の言語とは違う所が多いと思うからです。

実際のお勉強を重視する人は読み飛ばしてOKです。

### アセンブリ言語は難しい？簡単？

アセンブリ言語は、ソフトウェア開発者だとだいたいtwitterでイキるのに使われる程度です。
いわく「Cはマクロアセンブラ似すぎないから（キリッ」とか、「低レベルな方がわかりやすいので、アセンブリを先にやるとポインタもわかるよ（キリッ」とかそういう感じです。鬱陶しいですね。
彼らは別にアセンブリ自体の話はあんまりしない。

だいたいイキるのに使われるというのは、難しくて高度な事、という印象があるのでしょう。
実際、ソフトウェア開発者にとって、アセンブリ言語を理解するのは、難しい部分があります。

一方でアセンブリ言語が難しいか？というとそうでもありません。
あくまで「ソフトウェア開発者にとって」難しいのであって、
それ以外の人にとってはそんな難しくない、という事があります。
具体的にはハードウェア開発者などにはアセンブリ言語の方が簡単でしょう。

これはアセンブリ言語が、より抽象度が低いからです。下のハードウェアに近いので、下のハードウェアの知識があると、言語自体は大した事をしてないので理解が簡単です。

ハードウェアの知識、なんてなんか高度で難しそう！と思うかもしれませんし、
実際高度で難しいと思いますが、アセンブリ言語が難しい、というのはちょっと違う気もする。

抽象度が低い、というのは、思考としては逆に高度「では無い」という事だと思います。
この高度な思考を「捨てる」のが、高度で抽象的な思考に慣れているソフトウェア開発者にとってはちょっと難しい、
というか珍しい必要性を要求される所で、そこがアセンブリ言語の特殊さでもあります。

ただ抽象的じゃない、というのは、理解してしまえば難しさはそれほどはありません。
実際、アセンブリ言語「しか」理解出来ないという人は結構います。
ただそういう人はだいたいもう老人でweb上にはあんまり居ないので、

アセンブリ言語が出来る人＝＝そのほかの事もなんでもしってるすごい人

になりがちというだけです。

### アセンブリ言語は言語なのか？

C言語はプログラム言語です。これは皆が納得する事でしょう。
RubyでもPythonでもJavaでもKotlinでも、これらがプログラム言語なのは明らかで、
このプログラム言語についてある程度は説明する事も出来ます。

ですが、アセンブリ言語、というのは、「これがアセンブリ言語です」という意味でのアセンブリ言語は無い。
実際は「ARMのアセンブリ言語」とか「x86のアセンブリ言語」とかになります。
（さらにNASMとかgasとかありますが、それはおいとく）。

アセンブリ言語という物は実際には存在してないで、
それぞれCPUごとに別々言語があります。
そしてこれらの言語は、CPUの機能を、ほぼそのまま書いているだけだったりします。
だから、あるCPUの機能を理解する事と、アセンブリ言語の理解は、ほぼ同じ事を指します。

ここがアセンブリ言語の特殊な所です。プログラム言語単体の理解、というのがアセンブリ言語は出来ない。
逆にCPUの構造を理解するとアセンブリの理解も98%くらい終わってしまいます。
だからアセンブリ言語を勉強しよう、という時は、CPUの機能を勉強しよう、という事と同じなのです。
そしてCPUはそれぞれ別なので、どのCPUを勉強するか、という話になります。

言語という名前がついているけれど、実際はCPUの機能とほとんど同じ、という所がアセンブリ言語の特殊な所です。
CPUの機能とは独立した、抽象概念としての言語の実在があまり無い。

ただ、実際はいろいろなCPUは、それぞれかなり似通っています。
だから、一つのCPUを理解すると他のCPUも比較的簡単に学ぶ事は出来ます。
ですから、一つのアセンブリ言語を知っていると、アセンブリ言語を知っている、と言えない事も無い。


### アセンブリ言語は突然膨大な詳細情報が出てきがち

アセンブリ言語というのは、CPUを動かす為のバイナリと一対一に近い対応をしています。
完全に一対一では無くて、多対一で、アセンブリ言語の方が多ですが。
逆像は存在するので、どれかの元を選ぶ事で、逆アセンブルが出来る。

さて、CPUを動かすバイナリ、とは、要するにCPUにつながっている線のすべての電圧の組となります。
基本的には前のクロックに特定の電圧の組があると、次のクロックではある一定の電圧の組に変える、
というのがCPUの機能です。
この対応は完全に一意で、入力時の電圧を決めると、次のクロックは完全に決まります。

だから、原理的にはこの対応関係を全部記述すれば、分からない事はありません。
そこでアセンブリ言語のマニュアルというのは、
ある程度構造化された形でこの全対応を書いてあるものです。

これを調べれば全てが分かる。必要な事は全て書いてあって要らない物は無い。
素晴らしい。

これが他の言語を知っているソフトウェア開発者には辛い所です。
大量の詳細な情報がぶわーっと一気に出てくる。
ゆとりとしては、もっとこう、基礎的な所だけでまずはハローワールドとか書きたいのですが、
アセンブリ言語の情報というのは最初から全てを含んだpdfのみ、となりがちです。

そもそもにアセンブリ言語には説明すべき抽象概念があまり無く、
そこにあまり抽象的思考とかしないハードウェア開発者が書くという事があいまって、
ひたすら詳細が並んでるだけ、となってしまうのです。

そして実際、慣れてしまえばこれだけで十分でもあります。

結果として、大して難しくは無いのだけどとっつきにくい為、twitterでイキるのに使われてしまったりする。
悲しい事です。

### このシリーズでは、C言語に必要な程度だけ話す

私はそもそも、そんなにアセンブリ言語詳しくありません。
C言語を理解するには十分な知識を持っているつもりですが、ハードウェア屋とか低レベルプログラマの人たちに比べると、
だいぶ理解は浅い。

そこで今回も、アセンブリ言語のシステマティックで全体的な入門を書く気はありませんし、書く能力もありません。
その代わり、C言語の理解を深めるのに必要な範囲+アルファくらいの解説に留めようと思います。
ソフトウェア開発者にとってはアセンブリ言語の良い入門にもなると思いますが、
ちゃんと学ぶ時にはよそでお願いします。

ただ、この目的を絞っている方が、最初に全ての詳細が出てきてしまう、
という問題を回避出来るんじゃないか、と思っていますし、
解説としてもゆとりにも優しい感じを目指していきます。


## hello_asm.sを読む



ldr, str, add, cmp, bne, mov, .ascizなどを説明。
print_loop.sとhello_arm.sの解説。

# 03 アセンブリからC関数を呼ぶ

最低限のセットアップだけで関数を呼ぶ。リンカの使い方とかも。

# 04 リロケーションとリンカスクリプト

hello_arm.o, hello_arm.elf, hello_arm.binのバイナリを比較して、リロケーションの話を簡単に。
逆アセンブルもこの辺か。

# 05 簡易アセンブラを作ろう

リロケーション無しで簡単なアセンブリを作る。0x00010000決め打ち。



----

以下メモ


```
arm-none-eabi-objdump -S hello_arm.o
```

versatilepbはARM926EJ-S。
https://developer.arm.com/docs/ddi0198/latest/preface

ただデータシートの4章くらいが今回程度の知識なら妥当な気がする。
https://developer.arm.com/docs/ddi0027/latest/arm7di-data-sheet


C function call
https://developer.arm.com/products/architecture/cpu-architecture/a-profile/docs/ihi0042/e/procedure-call-standard-for-the-arm-architecture


versatilepb memorymap
https://github.com/hackndev/qemu/blob/master/hw/versatilepb.c